---
title: 'プリンシプル オブ プログラミング'
emoji: '🐥'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['プログラミング原則']
published: false
---

プリンシプル オブ プログラミングのピックアップ備忘録

# 第一章 前提

## 1.3. コードは必ず変更される

### 変更される理由

- 障害対応
- ユーザからの要望
- ユーザのビジネス環境の変化

### How

**変更に強いコードを書く**

- 変更に強いコードを書くために最も大切なことは、「コードが読みやすい」ということ
- コードは書いている時間よりも、読んでいる時間の方が長い

# 第二章 原則

## 2.1 KISS

_Keep It Simple, Stupid._

### How

**コードに余計なことをしない**

## 2.2 DRY

_Don't Repeat Yourself._

### How

**コードのコピペしない**

### Why

- コードを読む作業が難しくなる
- コードを修正する作業が難しくなる

**コードを抽象化する**

- ロジックを抽象化するには、処理のまとまりに名前を付けて、「関数化」「モジュール化」する
- データであれば、それに名前を着けて定数を定義する
- そして、それらを、繰り返し出てくる部分と置き換える

### 抽象化するメリット

- コード量がヘリ、読む量を減らせる
- ロジックやデータに「名前」が付くので、コードが読みやすくなる
- 同じコードが 1 箇所に集約され鵜、修正箇所が 1 箇所で済むので、コードが修正しやすくなり、品質が担保しやすくなります。
- 抽象化した部分は再利用しやすくなる。

## 2.3 YAGNI

_You Aren't Going to Need It._
それはきっと必要にならない。

- コードは必要最低限
- 「多分必要になるだろう」「必要ななるかもしれない」で書かない

## 2.5 SLAP

_Single Level of Abstraction Principle._
抽象化レベルの統一

抽象レベルが揃うと、結果的に、コードは優れた書籍のようになる。

```
function 高水準(){ // レベル1の目次
    中水準1();
    中水準2();
}

function 中水準1(){ // レベル2の目次-1
    低水準1();
    低水準2();
}

function 低水準1(){ // 本文内容
    // 処理
}
```

### How

- 関数を構造化する

## 2.6 OCP

_Open-Closed Principle_
オープン・クローズドの原則

コードの変更は波及させない

### Why

- コードの変更に柔軟に対応するため

### How

**コードにインターフェースを用いる**

- ある機能を持ったモジュールを設計する場合、モジュールの使用者「クライアント」が、モジュールの提供者「サーバー」を直接呼び出すと、「硬い」設計になります。別のサーバーを使用したい場合、クライアントを変更しないといけないから。

- そこで、クライアントとサーバーの間に、モジュール使用者のための「クライアントインターフェース」を設けます。
- サーバーは、クライアントインターフェースを実装することになります。

- これにより、新機能のサーバーが追加されたとしても、新サーバーがクライアントインターフェースを実装していれば、クライアントはサーバーの入れ替わりによってコードを変更することはありません。
- 既存コードが変更されることなく、機能追加を行うことが可能になります。

### 関連する「デザインパターン」

- Strategy パターン
- Observer パターン
- Template Method パターン
- Decorator パターン

## 2.7 名前重要

_Naming is important_

コード命名は最重要課題
名前は、コードを読む人への UI（ユーザインターフェース）

- 内部処理の隠蔽

### How

- コードはまず名前を決める
  - プログラミングは、まず、名前から入りましょう
  - 常に「使う側」「読む側」の視点に立って命名する
  - 「短いコメント」と捉えて、名前をつける
  - 複数候補を出す
  - 誤解されないか確認する
  - 「効果」と「目的」を説明し、「手段」には言及しない
  - テストを書く（使用者視点で考えられる）
  - 発音可能に
  - 検索可能に
